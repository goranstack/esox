= Esox Java Swing binding library
:toc: left
:icons: font
:sectnums:

Bind properties of models (Aspects) to Swing components (Aspect projectors) using instances of objects called
Aspect adapters

== Concepts

This section introduces some concepts needed to describe the design pattern. The concept descriptions are rather abstract, see section 3 for a concrete example.

=== Model
A model object represents an entity of the application domain. It has a set of aspects (see below).
Model objects are observable. This means that other objects (not necessarily model objects) can register themselves as listeners. Listeners are notified when the state of the model object changes. The most common model object state change is the change of an aspect value.

=== Aspect
A model object has a set of aspects. For each aspect the model object has methods for accessing (getting and/or setting) the aspect value. Normally an aspect has both get and set methods but read-only and write-only aspects are conceivable.

=== Submodel
Given a model object A, the value of one of its aspects can be another model object B. In this case B is said to be a submodel of A. B can be a submodel of many other model objects so no unambiguous super model relation exists.

=== Aspect projector
Aspect projectors are swing objects used for displaying and/or manipulating aspect values. Examples of such objects are instances of the classes JTextField, JComboBox, JCheckBox and JProgressBar.

=== Model owner
A model owner has a reference to a model object. The value of this reference is observable. This means that other objects can register themselves as listeners. Listeners are notified when the value of the reference changes.

=== Aspect adapter
An aspect adapter connects an aspect with an aspect projector. Its task is to keep the aspect value synchronized with the value displayed in the aspect projector. The aspect adapter is also responsible for all conversion between aspect values and projected values.


== Putting it all together
When created, an aspect adapter is given a reference to the aspect projector and a reference to a model owner. It also maintains a reference to a model object.
The purpose of reference the aspect projector is obvious. It makes it possible to access the projected value (the value displayed to the user) and to monitor user input.
The model object reference serves a similar purpose. It makes it possible to access and monitor the aspect.

.Aspect adapter and related objects
[graphviz, er-diagram, svg]
....
digraph {

node[ fontname="Helvetica", shape=rect];
edge[ fontname="Helvetica"];

i1 [label="model"];
i2 [label="model owner"];
i3 [label="aspect adapter"];
i4 [label="aspect"];
i5 [label="aspect projector"];

i2 -> i1 [label="knows"];
i1 -> i4 [label="knows"];
i3 -> i2 [label="observes model value"];
i3 -> i1 [label="observes aspect value\ngets aspect value\nsets aspect value"];
i3 -> i5 [label="monitor user inputs\ngets projected value\nsets projected value"];
}
....

In many cases, a reference to the model is not available when the aspect adapter is created. Another common scenario is a model owner which changes models during the lifespan of an aspect adapter. The aspect adapter must therefore observe the model owner in order to maintain a reference to the actual model.

[plantuml, model-reference, svg]
....
@startuml

hide footbox
title Maintaining the model reference

actor context

context -> "aspect adapter" : create(model owner, aspect)
"aspect adapter" -> "model owner" : listen to model value changes
"aspect adapter" -> "aspect projector" : listen to projected value
"aspect adapter" -> "aspect projector" : set no projected value
context -> "model owner" : set model( model )
"model owner" -> "aspect adapter" : notify of model value change
"aspect adapter" -> model : listen to aspect value changes
"aspect adapter" -> model : v = get aspect value
"aspect adapter" -> "aspect projector": set projected value( v )
context -> "model owner" : set model( null )
"model owner" -> "aspect adapter" : notify of model value change
"aspect adapter" -> model : unlisten to aspect value
"aspect adapter" -> "aspect projector" : set no projected value
@enduml
....

Aspect value and the projected value synchronization is achieved by monitoring both aspect value changes and user input. When user input occurs, the projected value is propagated from the aspect projector to the model. When the aspect value changes, it is propagated from the model to the aspect projector. All necessary value conversions are performed by the aspect adapter.

[plantuml, value-synchronization, svg]
....
@startuml

hide footbox
title Value synchronization

actor user
actor context

user -> "aspect projector" : enter new projected
"aspect projector" -> "aspect adapter" : notify of projected value
"aspect adapter" -> "aspect projector" : get projected value
"aspect adapter" -> model : set aspect value
context -> model : set aspect value
model -> "aspect adapter" : notify of aspect value change
"aspect adapter" -> model : get aspect value
"aspect adapter" -> "aspect projector" : set projected value
@enduml
....

== Submodels and model owners
A special case that warrants further description is the relations between models, submodels and model owners. Normally, a model-submodel pair is handled by a pair of model owners. A submodel adapter (which is actually a kind of read-only aspect adapter) assures that the two model owners stay synchronized. Synchronized in this case means that the (sub)model owner refers to the submodel of the model being referred to by the model owner. In the diagram below, the relations that are synchronized by the submodel adapter are represented by the thick arrows.

.Submodels and model owners
[graphviz, submodels, svg]
....
digraph {

node[ fontname="Helvetica", shape=rect];
edge[ fontname="Helvetica"];

i1 [label="model"];
i2 [label="model owner"];
i3 [label="submodel adapter"];
i4 [label="(sub)model"];
i5 [label="(sub)model owner"];

i2 -> i1 [label="knows"];
i1 -> i4 [label="knows"];
i3 -> i1 [label="observes submodel value\ngets submodel value"];
i3 -> i2 [label="observes model value"];
i3 -> i5 [label="sets submodel value"];
i5 -> i4 [label="knows"];
}
....

The diagram below illustrates the submodel owner synchronization behaviour. The first two scenarios describe what happens when the model property of the model owner is changed. The last scenario describe s what happens when the submodel aspect of the model is changed.
Note that the submodel adapter does not monitor the model property of the submodel owner. If it is changed by a call from another object (not the submodel owner) then the synchronization breaks.

[plantuml, submodel-synchronization, svg]
....
@startuml

hide footbox
title Submodel owner synchronization

actor context

context -> "model owner" : set model( model )
"model owner" -> "submodel adapter" : notify of model value change
"submodel adapter" -> model : listen to submodel value changes
"submodel adapter" -> model : v = get submodel
"submodel adapter" -> "(sub)model owner" : set model( v )
context -> "model owner" : set model( null )
"model owner" -> "submodel adapter" : notify of model value change
"submodel adapter" -> model : unlisten to submodel value
"submodel adapter" -> "(sub)model owner" : set model( null )
context -> model : set submodel ( v )
model -> "submodel adapter" : notify of submodel value
"submodel adapter" -> model : v = get submodel
"submodel adapter" -> "(sub)model owner" : set model( v )
@enduml
....

== Example
To illustrate the concepts introduced in the previous chapter weâ€™ll use a very simple example.
The model is implemented by the class Person which has the aspect name. The model owner is implemented by the class PersonPanel. PersonPanel is a descendant of the swing class JPanel. It contains an aspect projector which is an instance of the swing class JTextField. The class TextFieldAdapter implements the aspect adapter.
The figures in this chapter correspond to the figures in the previous chapter.


